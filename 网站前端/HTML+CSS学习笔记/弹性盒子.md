# 弹性盒子

## 目录
1. [`flex`语法](#flex语法)
1. [`flex`布局实践](#flex布局实践)

---

>`flex`适合一维布局，`grid`适合二维布局。

### `flex`语法
> 参考：[Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)、[写给自己看的display: flex布局教程](https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/)。

![flex图](./images/flex-1.png)

>1. 主轴：main axis。
>2. 侧轴（交叉轴）：cross axis。
>3. 默认的`direction: ltr`如下所示从左到右，若是`direction: rtl`则左右相反。
>4. `writing-mode`属性也会影响排版顺序。

1. Flex容器：设置为`display: flex;`（自己为块级）或`display: inline-flex;`（自己为行内）的元素。

    >1. 只决定子元素的排版方向和空隙展示类型。
    >2. 子元素的`float`、`clear`、`vertical-align`属性将失效。

    1. `flex-direction`：决定主轴的方向。

        1. `row`（默认）：水平方向，起点在左端。
        2. `row-reverse`：水平方向，起点在右端。
        3. `column`：垂直方向，起点在上沿。
        4. `column-reverse`：垂直方向，起点在下沿。
    2. `flex-wrap`：一条主轴排不下的情况，如何换行。

        1. `nowrap`（默认）：不换行。

            >若内容溢出，则表现和`white-space: nowrap`类似。
        2. `wrap`：换行，第一行在上方。
        3. `wrap-reverse`：换行，第一行在下方。

    - `flex-flow`：`flex-direction`（可选）、`flex-wrap`（可选）的简写形式，默认：`row nowrap`。

    3. `align-content`：多根主轴（一条主轴排不下，有换行）的对齐方式（不换行则该属性不起作用）。

        >与`flex-wrap: wrap/wrap-reverse;`同时使用。

        1. `stretch`（默认）：拉伸所有行来填满剩余空间。剩余空间平均的分配给每一行。
        2. `flex-start`：与侧轴的起点对齐。
        3. `flex-end`：与侧轴的终点对齐。
        4. `center`：与侧轴的中点对齐。
        5. `space-between`：与侧轴两端对齐，轴线之间的间隔平均分布。
        6. `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
    4. `justify-content`：子项在主轴上的对齐方式（与轴的方向有关）。

        >假设主轴的方向为从左到右，起点就是左、终点就是右。

        1. `flex-start`（默认）：起点对齐。
        2. `flex-end`：终点对齐。
        3. `center`：居中。
        4. `space-between`：两端对齐，子项之间的间隔都相等。
        5. `space-around`：每个子项两侧的间隔相等。所以，子项之间的间隔比子项与边框的间隔大一倍。
    5. `align-items`：子项在侧轴上的对齐方式（与轴的方向有关）。

        >假设侧轴的方向为从上到下，起点就是上、终点就是下。

        1. `stretch`（默认）：若子项未设置高度或设为`auto`，则将占满整个容器的高度。
        2. `flex-start`：起点对齐。
        3. `flex-end`：终点对齐。
        4. `center`：居中。
        5. `baseline`：子项的第一行文字的基线对齐。
2. Flex子项：Flex容器内的子元素。

    1. `order`：子项的排列顺序。数值越小，排列越靠前（整数值、允许负值），默认：`0`。
    2. `flex-grow`：子项的拉伸因子（放大比例），默认：`0`（若存在剩余空间，也不放大）。

        - 若所有子项的`flex-grow`属性都为1，则它们将平分剩余空间（若有的话）。
        - 若一个子项的`flex-grow`属性为2，其他子项都为1，则前者占据的剩余空间是其他子项的2倍。
    3. `flex-shrink`：子项的缩小比例，默认：`1`（若空间不足，则该子项将缩小）。

        - 若所有子项的`flex-shrink`属性都为1，则当空间不足时，都将等比例缩小。
        - 若一个子项的`flex-shrink`属性为0，其他子项都为1，则当空间不足时，前者不缩小。
        - 若一个子项的`flex-shrink`属性为2，其他子项都为1，则当空间不足时，前者缩小是其他子项的2倍。
    4. `flex-basis`：在分配多余空间之前，子项占据的主轴空间。默认：`auto`（子项的本来大小）。

        设置具体值使子项占据固定空间。

        >浏览器根据这个属性，计算主轴是否有多余空间。

    - `flex`：`flex-grow`、`flex-shrink`（可选）、`flex-basis`（可选）的简写形式，默认：`0 1 auto`。

        该属性有两个快捷值：`auto`（1 1 auto）和`none`（0 0 auto）。

    5. `align-self`：单个子项覆盖父元素的`align-items`。

        1. `auto`（默认）：继承父元素的`align-items`属性，若没有父元素，则等同于`stretch`。
        2. `stretch`：拉伸所有行来填满剩余空间。剩余空间平均的分配给每一行。
        3. `flex-start`：与侧轴的起点对齐。
        4. `flex-end`：与侧轴的终点对齐。
        5. `center`：与侧轴的中点对齐。
        6. `space-between`：与侧轴两端对齐，轴线之间的间隔平均分布。
        7. `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。

- Flex容器内的子元素也可以设置为`display: flex;`，继续在其内部处理其子级的布局问题。

### `flex`布局实践
>参考：[Solved by Flexbox](https://magic-akari.github.io/solved-by-flexbox/)。

1. 栅格系统

    <details>
    <summary>充满剩余空间的子级添加<code>flex-grow: 1;</code>；占用固定宽度的子级添加固定宽度或父级百分比宽度。</summary>

    ```html
    <style>
      .father {
        display: flex;
      }
      .son {
        box-shadow: 0 0 1px 1px red inset;
      }
    </style>

    <div class="father">
      <div class="son" style="flex-grow: 1">  <!-- 填补剩余空间 -->
        auto
      </div>
      <div class="son" style="width: 40px;">  <!-- 固定宽度 -->
        width: 40px
      </div>
      <div class="son" style="width: 50%;"> <!-- 父级百分比宽度 -->
        width: 50%
      </div>
    </div>
    ```
    </details>
2. 一边固定宽度，一边自适应宽度的：

    <details>
    <summary>固定的子级添加：<code>flex-shrink: 0; width: 固定宽度;</code>；自适应的子级添加：<code>flex-grow: 1;</code>。</summary>

    >可以用`flex-basis: 固定宽度; overflow: hidden;`代替`width: 固定宽度`。

    ```html
    <style>
      .father {
        display: flex;
      }
      .son1 {
        flex-shrink: 0; /* 当空间不足时，不缩小 */
        width: 50px; /* 固定宽度 */

        background: red;
      }
      .son2 {
        flex-grow: 1; /* 填补剩余空间 */

        background: blue;
        margin-left: 10px;
      }
    </style>

    <div class="father">
      <div class="son1">固定宽度的，不能被挤压、也不自适应增加宽度</div>
      <div class="son2">自适应宽度的，占据剩下的所有内容</div>
    </div>
    ```
    </details>
3. 粘性页脚

    <details>
    <summary><code>&lt;body></code>添加：<code>display: flex; min-height: 100vh; flex-direction: column;</code>；主要内容添加：<code>flex-grow: 1;</code>。</summary>

    ```html
    <style>
      .body {
        display: flex;
        min-height: 100vh; /* 最小高度是屏幕高度 */
        flex-direction: column; /* 主轴的方向为垂直方向 */
      }

      .main {
        flex-grow: 1; /* 填补剩余空间 */
      }
    </style>

    <body class="body">
      <main class="main">主要内容<br></main>
      <footer>页脚</footer>
    </body>
    ```
    </details>
4. 居中并且可以内部滚动（以横轴为例）：

    <details>
    <summary>父级添加：<code>overflow-x: auto; text-align: center;</code>；子级添加：<code>display: inline-flex;</code>。</summary>

    ```html
    <style>
      .father {
        overflow-x: auto; /* 内嵌滚动条 */
        text-align: center; /* 子级行内元素居中 */
      }
      .son {
        display: inline-flex; /* 子级设置为行内元素 */
      }

      img + img {
        margin-left: 5px;
      }
    </style>

    <div class="father">
      <div class="son">
        0到无数个：<img src="https://via.placeholder.com/100">
      </div>
    </div>
    ```
    </details>

>骰子的[JSFiddle demo](https://jsfiddle.net/realgeoffrey/qvsLnksy/)。
